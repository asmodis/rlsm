require File.join(File.dirname(__FILE__), 'helper')
require File.join(File.dirname(__FILE__), 'binary_operation')
require File.join(File.dirname(__FILE__), 'dfa')
require File.join(File.dirname(__FILE__), 'monoidmods')
RLSM::require_extension 'array'
RLSM::require_extension 'monoid'

module RLSM
    
  class Monoid
    private_class_method :new

    
    attr_accessor :elements, :order, :binary_operation

    extend MonoidIterator
    include MonoidCompareMethods
    include MonoidGreenRelations
    include MonoidSyntacticStuff
    include MonoidSpecialElements
    
    #Like new, but without validation.
    def self.new!(description)
      new RLSM::BinaryOperation.new!(description)
    end

    #Creates a Monoid with the binary operation described in +description+. 
    #Validates that the BinaryOperation is assoviative and the neutral element 
    #is in the first row.
    #
    #See also BinaryOperation::new.
    def self.[](description)
      binop = RLSM::BinaryOperation.new(description)
      binop.enforce_associativity
      enforce_identity_position(binop.table, binop.order)

      new(binop)
    end


    #:notnew:
    #*Remark*: No validation is performed. Use it only when you're really know what to do.
    #Use Monoid::[] instead (or Monoid::new!).
    def initialize(binop)
      @binary_operation = binop
      @elements = @binary_operation.elements
      @order = @elements.size

      instance_eval(&block) if block_given?
    end

    #Calculates the product of the given elements.
    def [](*args)
      case args.size
      when 0,1
        raise ArgumentError, "At least two elements must be provided."
      when 2
        @binary_operation[*args]
      else
        args[0,2] = @binary_operation[args[0],args[1]]
        self[*args]
      end
    end

    def to_s # :nodoc:
      result = ""
      sep = @elements.any? { |x| x.length > 1 } ? ',' : ''
      @binary_operation.table.each_with_index do |el,i|
        result += @binary_operation.elements[el]
        if (i+1) % (@order) == 0
          result += ' '
        else
          result += sep unless i = @order**2 - 1
        end
      end

      result
    end

    def inspect # :nodoc:
      "<#{self.class}: #{to_s}>"
    end

    

    #Returns the submonoid generated by +set+.
    #
    #*Remark*: The returned value is only an Array, no Monoid. Use get_submonoid for this.
    def generated_set(set)
      if set.include? @elements.first
        gen_set = set.map { |element| element.to_s }
      else
        gen_set = set.map { |element| element.to_s } | @elements[0,1]
      end

      unfinished = true
      
      while unfinished
        unfinished = false

        gen_set.each do |el1|
          gen_set.each do |el2|
            element = self[el1,el2]
            unless gen_set.include? element
              gen_set << element
              unfinished = true
            end
          end
        end
      end
        
      gen_set.sort(&element_sorter)
    end

    #Returns the submonoid generated by set.
    def get_submonoid(set)
      elements = generated_set(set)

      set_to_monoid(elements)
    end

    #Returns an array of all submonoids (including the trivial monoid and the monoid itself).
    def submonoids
      candidates = get_submonoid_candidates
      candidates.map { |set| set_to_monoid(set) }
    end

    #Returns an array of all proper submonoids. 
    def proper_submonoids
      candidates = get_submonoid_candidates.select do |cand| 
        cand.size > 1 and cand.size < @order 
      end

      candidates.map { |set| set_to_monoid(set) }
    end

    #Returns the smallest set (first in terms of cardinality, then lexicographically) which generates the monoid.
    def generating_subset
      sorted_subsets.find { |set| generated_set(set).size == @order }
    end





    #Returns the monoid.
    def to_monoid
      self
    end

    #Returns a regular expression which represents a language with a syntactic monoid isomorph to +self+.
    def to_regexp
      to_dfa.to_regexp
    end

    #Returns a DFA which represents a language with a syntactic monoid isomorph to +self+.
    def to_dfa(finals = nil)
      finals = finals || disjunctive_subset || []

      if syntactic?
        unless all_disjunctive_subsets.include? finals
          raise MonoidError, "#{finals} isn't a disjunctive subset."
        end
      end

      string = "}s#{@elements.index(identity)} "

      finals.each do |element|
        string += "*s#{@elements.index(element)} "
      end

      generating_subset.each do |let|
        @elements.each do |start|
          string += "s#{@elements.index(start)}-#{let}->s#{@elements.index(self[start,let])} "
        end
      end

      RLSM::DFA.new string   
    end

    private
    def set_to_monoid(set)
      description = set.map do |el1|
        set.map { |el2| self[el1,el2] }.join(",")
      end

      RLSM::Monoid[ description.join(' ') ]
    end

    def element_sorter
      Proc.new { |el1,el2| @elements.index(el1) <=> @elements.index(el2)}
    end

    def subset_sorter
      Proc.new do |set1,set2|
        if set1.size == set2.size
          set1.map { |el| @elements.index(el) } <=> 
            set2.map { |el| @elements.index(el) }
        else
          set1.size <=> set2.size
        end
      end
    end

    def sorted_subsets
      subsets = @elements.powerset

      subsets.sort(&subset_sorter)
    end
    
    def get_submonoid_candidates
      submons =  []
      
      @elements.powerset.each do |set|
        candidate = generated_set(set)
        submons << candidate unless submons.include? candidate
      end

      submons.sort(&subset_sorter)
    end

    def bijective_maps_to(other)
      return [] if @order != other.order

      other.elements.permutations.map do |perm| 
        Hash[*@elements.zip(perm).flatten]
      end
    end

    def isomorphism?(map,other)
      @elements.each do |el1|
        @elements.each do |el2|
          return false if map[self[el1,el2]] != other[map[el1],map[el2]]
        end
      end

      true
    end

    def antiisomorphism?(map,other)
      @elements.each do |el1|
        @elements.each do |el2|
          return false if map[self[el1,el2]] != other[map[el2],map[el1]]
        end
      end

      true
    end

    def green_classes(type)
      not_tested = @elements.dup
      classes = []

      until not_tested.empty?
        classes << self.send((type + '_class').to_sym, not_tested.first)
	not_tested = not_tested.reject { |el| classes.last.include? el }
      end

      classes.sort(&subset_sorter)
    end

    def green_trivial?(type)
      @elements.all? { |el| self.send((type + '_class').to_sym, el).size == 1 }
    end
  end   # of class Monoid
end     # of module RLSM
