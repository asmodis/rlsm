require File.expand_path(File.join(File.dirname(__FILE__), '..', 'rlsm'))

=begin rdoc
==Basic theory of deterministic finite automaton (short DFA)
===Terminology
We will call a finite nonempty set an _alphabet_ and we will call an element of an alphabet a _letter_.

The free monoid generated by an alphabet +A+ will be denoted by +A*+ and is also called the _Kleene_-_closure_ of +A+. An element of +A*+ will be called a _word_ and will be written in the following text in a string notation: 'abcaac...'.

===Definition of a DFA
A DFA is a five tuple <tt>(A,S,i,F,T)</tt> where
* +A+ is an alphabet,
* +S+ is a nonempty set,
* +i+ is an element of +S+,
* +F+ is a subset of +S+ and
* <tt>T:AxS -> S</tt> is a function.

The elements of +S+ are called _states_, +i+ is the _initial_ _state_ and elements of +F+ are called _final_ _states_ (or _accepting_ _states_). The function +T+ is called the _transition_ _function_ of the DFA.


In the following we will define some properties of a DFA and of states which will be of some interest:

===The generalized transition function +T*+
Given a DFA, a generalized version of the transition function <tt>T*: A*xS -> S</tt> can be recursivly defined by
 T*('',s) := s
 T*('a',s) := T(a,s)
 T*('abcd...',s) := T*('bcd...',T(a,s))

It isn't really necessary to define +T*+, but it helps to define further properties in a concise way.

===Isomorphic DFAs
Like always we want to describe in what cases we consider two DFAs to be the same:

Let <tt>M=(A,S,i,F,T), N=(A',S',i',F',T')</tt> be two DFAs. A bijective map <tt>I : S -> S'</tt> is called an _isomorphism_ iff
1. <tt>A = A'</tt>
2. <tt>I(i) = i'</tt>
3. For all +f+ in +F+ it is +I(f)+ in +F'+
4. For all states +s+ in +S+ and all letters +l+ in +A+ it is <tt>I(T(l,s)) = T'(l,I(s))</tt>

We say +M+ is _isomorph_ _to_ +N+ if such an isomorphism exists. We see, two isomorphic DFAs differs only in the "names" of the states, so a distinction isn't very useful.

===The language of a DFA
Let +M+ be a DFA. The subset of +A*+ defined by
 L(M) := { w in A* | T*(w,i) is a final state }
is a formal language, in fact it is a _regular_ _language_. It is called the _language_ _generated_ _by_ +M+.

In almost all cases, if we study a DFA +M+ we are only interested in the language +L(M)+. Obviously two isomorphic DFAs generates the same language, but there are also non-isomorphic DFAs which generates the same language. This motivates the following definition: two DFAs +M+ and +N+ are _equivalent_ iff <tt>L(M) = L(N)</tt>.

It is easy to see, that this relation is an equivalence relation and we can define the equivalence class of a DFA +M+:
 [M] := { N | N is a DFA which is equivalent to M }

===The minimal DFA of a regular language
Let +L+ be a regular language and +M+ a DFA with <tt>L(M) = L</tt>. We will define a order '<' on the set +[M]+ by
 N < M :<=> N has less states than M
Because the number of states is an integer, there exists a DFA which has a minimal number of states. Such a DFA is called a _minimal_ DFA for +L+.

It has been shown that two minimal DFAs for a language +L+ are isomorphic. So we can talk about _the_ minimal DFA for +L+.

==An algorithm to find a minimal DFA
Let <tt>M = (A,S,i,F,T)</tt> be a DFA. The goal of this paragraph is to find an equivalent minimal DFA for +L(M)+.

Because we know, that some states have no influence on the generated language, we must find some criterias which states  aren't required.

===Unreachable states
We notice, that in the definition it isn't required, that for each state +s+ a word +w+ exists, such that <tt>T*(w,i) = s</tt>. We will call a state +s+ _reachable_ if such a word exists and _unreachable_ otherwise.

It is easy to see, that an unreachable state has no impact on the generated language, so a first step towards a minimal DFA is to reject all unreachable states.

A problem may be, that after removing the unreachable states, say the remaining states are +S'+, it is now possible that <tt>T|AxS'</tt> isn't defined everywhere. We will treat this in the next paragrapgh

===Completeness of a DFA
It is convenient to discard the requirement, that +T+ is defined on +AxS+. It is for most use-cases sufficent, that +T+ is a function on a subset +D(T)+ of +AxS+.

In this case, we say a state +s+ _accepts_ the letter +c+ if <tt>(c,s)</tt> is an element of +D(T)+. We say a DFA is _complete_ iff +D(T)=AxS+, i.e. each state accepts all alphabet letters.

====An algorithm to complete a DFA
If we have a noncomplete DFA <tt>(A,S,I,F,T)</tt> we can complete it in the following way:
1. Add a _trap_ _state_ +t+.
2. Define <tt>T':Su{t} -> Su{t}</tt> by <tt>T'=T</tt> for points where +T+ is defined and <tt>T'(c,s) = t</tt> elsewhere.
Now the DFA <tt>(A,Su{t},I,F,T')</tt> is complete.

====Remark
For a noncomplete DFA +M+ it is also possible to define a generalized transition function: If +N+ is the in the above way completed DFA of +M+ and +F+ its generalized transition function. We define
 D(T*) := { (w,s) | w in A*, F(w,s) != t }
and
 T* := F|D(T*)
Now +T*+ is a generalized transition function for a noncomplete DFA.

Also the completion doesn't change the generated language.

===Equivalent states
We say two states <tt>s,t</tt> are _equivalent_ iff for all words +w+ <tt>T*(w,s)</tt> is a final state iff and only if <tt>T*(w,t)</tt> is a final state.

This is an equivalence relation on the states +S+.

===Dead states
We say a state +s+ is _dead_ (or a _trap_ _state_) iff for all letters +l+ <tt>T(l,s) = s</tt> and +s+ isn't a final state.

The same as for unreachable states is true for dead states. They have no influence on the generated language. Moreover each dead state is equivalent to another dead state, because both aren't final states and they don't change for a word.

===The algorithm
0. Eliminate all unreachable states (leaving a potential uncomplete DFA)
1. Partitionate the set of remaining states by the equivalence relation of states. We get a set +S'+ of equivalence classes of states.
2. Define +i'+ to be +[i]+ in +S'+.
3. Define +F'+ to be the classes +[f]+ for each +f+ in +F+.
4. Define <tt>T' : AxS' -> S'</tt> by <tt>T'(l,[s]) := [T(l,s)]</tt>

The DFA (A,S',i',F',T') is then a minimal DFA (but not necessarily complete anymore). If one whishes a complete minimal DFA, complete the previous DFA.

For the calculation of the partition there are several algorithms but we choose the table filling algorithm.
=end

class RLSM::DFA
=begin rdoc
This method takes as parameter a hash with following required keys:
[:+initial+] The initial state.
[:+finals+] An array of the final states.
[:+transitions+] An array of the transitions.
=end
  def self.create(args = {})
    args[:transitions].map! { |t| t.map { |x| x.to_s } }
    args[:initial] = args[:initial].to_s
    args[:finals].map! { |f| f.to_s }
    args[:alphabet] = args[:transitions].map { |t| t.first }.uniq.sort
    args[:states] = args[:transitions].map { |t| t[1,2] }.flatten.uniq.sort

    new args
  end
=begin rdoc
It is not intended to use this method directly, use create instead.

This method takes as parameter a hash with following required keys:
[:+alphabet+] An array of alphabet characters.
[:+states+] An array of states.
[:+initial+] The initial state.
[:+finals+] An array of the final states.
[:+transitions+] An array of the transitions.

It is required that all occuring states are in the states array and all transition labels are in the alphabet. Also the states and the alphabet must be unique.
=end
  def initialize(args = {})
    validate_presence_of_required_keys(args)

    validate_uniqueness_of_alphabet_and_states(args)
    validate_transition_labels_are_in_the_alphabet(args)
    validate_all_states_matches(args)
    validate_transition_uniquness(args)

    @alphabet = args[:alphabet].sort
    @states = args[:states].clone
    @initial_state = args[:initial].clone
    @finals = args[:finals].clone
    @transitions = args[:transitions].inject({}) do |res,tr|
      (res[tr.first] ||= {})[tr[1]] = tr[2]
      res
    end
  end

  attr_reader :alphabet, :states, :initial_state, :finals

  #Returns an Array with 3-tuples as transitions.
  def transitions
    res = []
    @alphabet.each do |letter|
      res |= @transitions[letter].to_a.map { |x| [letter] + x }
    end

    res
  end

  #Returns the number of states.
  def num_states
    @states.size
  end

  #Returns the number of final states.
  def num_finals
    @finals.size
  end

  #Returns the state in which the DFA halts if started in state +s+ and given the word +w+. Returns +nil+ if some state doesn't accept the actual character on the way.
  def [](w,s)
    unless @states.include? s
      raise DFAException, "Given state '#{s}' isn't a state in this DFA."
    end

    w.scan(/./).inject(s) do |s, c|
      unless @alphabet.include? c
        raise DFAException, "Given character '#{c}' isn't in the alphabet."
      end
      @transitions[c][s]
    end
  end

  #Returns true if the DFA accepts +word+.
  def accepts?(word)
    @finals.include? self[word,@initial_state]
  end


  #Returns true if there exists an isomorphism between this DFA and +other+.
  def isomorph_to?(other)
    #Test first some required conditions
    return false unless @alphabet == other.alphabet
    return false unless @states.size == other.num_states
    return false unless @finals.size == other.num_finals

    #Find an isomorphism if possible
    iso = @states.permutations.find do |p|
      isomorphism?(p, other)
    end

    iso ? true : false
  end

  #Returns true if the state is reachable, raises an Exception if the state isn't in the DFA.
  def reachable?(state)
    raise DFAException, "Unknown state: #{state}" unless @states.include? state
    (@reachable_states ||= reachable_states).include? state
  end

  #Returns true if given state is dead, raises an Exception if the state isn't in the DFA.
  def dead?(s)
    raise DFAException, "Unknown state: #{s}" unless @states.include? s

    s != @initial_state and
      !@finals.include?(s) and
      @alphabet.all? { |l| [nil,s].include? self[l,s] }
  end

  #Returns true if the dfa is minimal.
  def minimal?
    return false unless connected?
    get_equivalent_states.empty?
  end

  #Returns true if the DFA is complete.
  def complete?
    @states.all? { |s| @alphabet.all? { |l| self[l,s] } }
  end

  #Returns a complete DFA which generates the same language. If there exists already a dead state, this state will be used to complete the DFA.
  def complete!
    trap = @states.find { |s| dead?(s) }

    #No dead states present? -> create one
    unless trap
      trap = @states.sort.last.succ
      @states << trap
    end

    @states.each do |s|
      @alphabet.each do |l|
        (@transitions[l] ||= {})[s] = trap unless self[l,s]
      end
    end

    self
  end

  #Returns +true+ if the DFA has no unreachable states.
  def connected?
    @states.all? { |s| reachable?(s) }
  end

  #Returns a DFA with no unreachable states.
  def connect!
    remove_states *@states.find_all { |s| !reachable?(s) }
    self
  end

  #Returns +true+ if the DFA has dead states.
  def dead_states?
    @states.any? { |s| dead?(s) }
  end

  #Removes all dead states.
  def remove_dead_states!
    remove_states *@states.find_all { |s| dead?(s) }
    self
  end

=begin
Minimizes the DFA. Takes as optional parameter a hash with only processed key :+rename+. The possible values are:
[:+new+] States will be renamed to 's0', 's1', ...
[:+min+] For each class of states the state with the smallest name is taken
[:+join+] The names from each class are joined, so a class with states 'a' and 'b' will yielld a new state 'ab'. This is the default.
=end
  def minimize!(opts = {})
    connect!
    remove_dead_states!
    unless minimal?
      part = state_partition
      merge_states *part

      case opts[:rename]
      when :new : rename_states()
      when :min : rename_states part.map { |cls| cls.min }
      else
        rename_states part.map { |cls| cls.join }
      end
    end

    self
  end

  #Renames the state to the given array. Raises an exception if this array has the wrong size or the elements aren't unique.
  def rename_states(arg = nil)
    arg ||= (0...@states.size).map { |i| "s#{i}" }

    if arg.size != @states.size
      raise DFAException, "Wrong number of state names given."
    end

    if arg.uniq!
      raise DFAException, "Given state names weren't unique."
    end

    rename_transitions arg

    @initial_state = arg[@states.index(@initial_state)]
    @finals.map! { |f| arg[@states.index(f)] }

    @states = arg.clone
  end

  #Returns a connected copy of the DFA.
  def connect
    Marshal.load(Marshal.dump(self)).connect!
  end

  #Returns a complete copy of the DFA.
  def complete
    Marshal.load(Marshal.dump(self)).complete!
  end

  #Returns a minimized copy of the DFA.
  def minimize(opts = {})
    Marshal.load(Marshal.dump(self)).minimize!(opts)
  end

  #Returns +true+ if this DFA is equivalent to +other+
  def equivalent_to?(other)
    minimize.isomorph_to?(other.minimize)
  end

  #Returns the transition monoid of the DFA.
  def transition_monoid
    RLSM::Monoid.new get_binary_operation, :rename => true
  end

  #Returns the transition monoid of the equivalent minimal DFA.
  def syntactic_monoid
    minimize.transition_monoid
  end

  #Synonym for syntactic_monoid
  def to_monoid
    syntactic_monoid
  end

  #Returns self.
  def to_dfa
    self
  end

  #Returns a RE which represents the same language.
  def to_re
    les = []
    les << initialize_row_for(initial_state)
    (@states - [initial_state]).each do |state|
      les << initialize_row_for(state)
    end

    #Solve for the initial state
    les = update_les(les, simplify_les_row(les.pop)) until les.size == 1

    simplify_les_row(les.pop)[:final]
  end

  def inspect
    "<#{self.class}: #{@states.join(',')}>"
  end

  def to_s
    output = []
    output << @states.inject(['']) do |res, state|
      prefix = ''
      prefix += '*' if @finals.include? state
      prefix += '->' if initial_state == state

      res + [prefix + ' ' + state + ' ']
    end

    @alphabet.each do |letter|
      column = [' ' + letter + ' ']
      @states.each do |state|
        tmp = self[letter,state]
        if tmp.nil?
          column << ' nil '
        else
          column << ' ' + tmp + ' '
        end
      end

      output << column.clone
    end

    #Align output
    output.map! do |col|
      max_length = col.map { |x| x.length }.max
      col.map { |x| ' '*(max_length - x.length) + x }
    end

    rows = (0..@states.size).map { |i| output.map { |col| col[i] } }
    rows.map! { |row| row.join('|') }
    head = rows.shift
    rows.unshift head.scan(/./).map { |c| c == '|' ? '+' : '-' }.join
    rows.unshift head

    rows.join("\n")
  end

  private
  def initialize_row_for(state)
    row = { :state => state.clone }
    @states.each do |s|
      row[s] = RLSM::RE.new
    end

    @alphabet.each do |letter|
      row[self[letter, state]] += RLSM::RE.new(letter) if self[letter, state]
    end

    if @finals.include? state
      row[:final] = RLSM::RE.new(RLSM::RE::Lambda)
    else
      row[:final] = RLSM::RE.new
    end

    row
  end

  def update_les(l,r)
    l.map do |row|
      re = row[r[:state]]
      @states.each do |state|
        if state == r[:state]
          row[state] = RLSM::RE.new
        else
          row[state] += re * r[state]
        end
      end

      row[:final] += re * r[:final]
      row
    end
  end

  def simplify_les_row(row)
    #Have we something like Ri = ... + xRi + ...
    if row[row[:state]].pattern != ''
      re = row[row[:state]].star
      @states.each do |state|
        if state == row[:state]
          row[state] = RLSM::RE.new
        else
          row[state] = re * row[state]
        end
      end

      row[:final] = re * row[:final]
    end

    row
  end

  def rename_transitions(arg)
    @transitions = @transitions.to_a.inject({}) do |res,pair|
      res[pair.first] = pair.last.map do |key,val|
        [arg[@states.index(key)], arg[@states.index(val)]]
      end.inject({}) { |r,v| r[v.first] = v.last; r }
      res
    end
  end

  def get_binary_operation
    maps = []
    elements = []
    l = 0
    loop do
      new = false
      each_word_of_length(l) do |w|
        map = get_map(w)
        unless maps.include? map
          maps << map
          elements << w
          new = true
        end
      end
      break unless new
      l += 1
    end

    binop = []
    (0...elements.size).to_a.product((0...elements.size).to_a).each do |i,j|
      (binop[i] ||= [])[j] = maps.index(get_map(elements[i] + elements[j]))
    end

    binop
  end

  def each_word_of_length(l)
    word = (@alphabet.first.to_s*l).scan(/./)
    yield word.join

    until word == (@alphabet.last.to_s*l).scan(/./)
      word = get_next_word(word)
      yield word.join
    end
  end

  def get_next_word(word)
    i = (1..word.length).find { |i| word[-i] != @alphabet.last }
    word[-i] = @alphabet[@alphabet.index(word[-i])+1]
    if i > 1
      (1...i).each do |j|
        word[-j] = @alphabet.first
      end
    end

    word
  end

  def get_map(word)
    @states.map { |s| self[word,s] }
  end

  def remove_states(*states)
    @reachable_states = nil
    #Remove the state
    states.each do |s|
      @states.delete(s)
      @finals.delete(s)
    end

    #Remove the transitions
    @alphabet.each do |l|
      tr = @transitions[l].map.reject { |p| states.any? { |s| p.include? s } }
      @transitions[l] = tr.inject({}) { |r,x| r[x.first] = x.last; r }
    end
  end

  def get_renaming_scheme(classes)
    classes.inject({}) do |res,cls|
      state = select_state_in cls
      cls.each do |x|
        res[x] = state
      end
      res
    end
  end

  def merge_states(*classes)
    @reachable_states = nil
    rename = get_renaming_scheme(classes)

    @states.map! { |s| rename[s] }.uniq!
    @finals.map! { |s| rename[s] }.uniq!

    @alphabet.each do |l|
      tr = @transitions[l].map { |x,y| [rename[x],rename[y]] }.uniq
      @transitions[l] = tr.inject({}) { |r,x| r[x.first] = x.last; r }
    end
  end

  def select_state_in(cls)
    if cls.include? @initial_state
      @initial_state
    else
      cls.min
    end
  end

  def state_partition
    eq = get_equivalent_states
    @states.inject([]) do |res,s|
      res << [s]
      eq.find_all { |p| p.include? s }.each do |pair|
        res[-1] |= pair
      end

      res.last.sort!
      res.uniq
    end
  end

  def set_up_table_fill_algorithm
    (@states | (complete? ? [] : [nil])).unordered_pairs.partition do |x,y|
      @finals.include?(x) ^ @finals.include?(y)
    end
  end

  def table_fill_step(dis, equi)
    equi.select do |x,y|
      @alphabet.any? do |l|
        dis.include? [@transitions[l][x], @transitions[l][y]] or
        dis.include? [@transitions[l][y], @transitions[l][x]]
      end
    end
  end

  def get_equivalent_states
    distinguished, equivalent = set_up_table_fill_algorithm

    loop do
      new_dis = table_fill_step distinguished, equivalent
      break if new_dis.empty?
      distinguished |= new_dis
      equivalent -= new_dis
    end
    equivalent.reject { |p| p.include? nil }
  end

  def reachable_states
    reachable = []
    new_states = [@initial_state]

    until new_states.empty?
      reachable |= new_states
      new_states = []
      reachable.each do |s|
        @alphabet.map do |l|
          new_states << self[l,s] unless reachable.include? self[l,s]
        end
      end
      new_states.compact!
    end

    reachable
  end

  def get_bijective_map_to(p, other)
    @states.inject({}) do |res,s|
      res[s] = other.states[p.index(s)]
      res
    end
  end

  def isomorphism?(per, o)
    p = get_bijective_map_to(per, o)
    return false unless o.initial_state == p[@initial_state]

    unless @finals.map { |s| p[s] }.all? { |f| o.finals.include? f }
      return false
    end

    @alphabet.product(@states).all? do |c,s|
      p[self[c,s]] == o[c,p[s]]
    end
  end

  def validate_presence_of_required_keys(args)
    [:alphabet,:states,:initial,:finals,:transitions].each do |key|
      raise DFAException, "No #{key} given!" unless args.key?(key)
    end
  end

  def validate_all_states_matches(args)
    unless args[:states].include? args[:initial]
      raise DFAException, "Given initial state isn't in :states."
    end

    bad = args[:finals].find_all { |x| !args[:states].include?(x) }
    unless bad.empty?
      raise(DFAException,
            "Given final states #{bad.inspect} aren't in :states.")
    end

    bad = args[:transitions].find_all do |l,x,y|
      !(args[:states].include?(x) and args[:states].include?(y))
    end
    unless bad.empty?
      raise(DFAException,
            ("Given transitions #{bad.inspect}" +
            "have states which aren't in :states."))
    end
  end

  def validate_uniqueness_of_alphabet_and_states(args)
    [:alphabet, :states].each do |key|
      if args[key].uniq!
        raise(DFAException,
              "#{key} has duplicated entries: #{args[key].inspect}")
      end
    end
  end

  def validate_transition_labels_are_in_the_alphabet(args)
    bad = args[:transitions].find_all { |l,x,y| !args[:alphabet].include?(l) }
    unless bad.empty?
      raise(DFAException,
            ("Following transitions contain non alphabet characters:" +
            "#{bad.inspect}."))
    end
  end

  def validate_transition_uniquness(args)
    args[:alphabet].product(args[:states]).each do |c,s|
      tr = args[:transitions].find_all { |l,s1,s2| l == c and s1 == s }
      if tr.size > 1
        raise DFAException, ("There are multiple transitons from state " +
                             "#{tr.first[1]} with label #{tr.first[0]}.")
      end
    end
  end
end
